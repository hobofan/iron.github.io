initSidebarItems({"enum":[["Protocol","Protocol used to serve content. Future versions of Iron may add new protocols to this enum. Thus you should not exhaustively match on its variants."]],"macro":[["iexpect!","Unwrap the given Option or return a Ok(Response::new()) with the given modifier. The default modifier is status::BadRequest."],["itry!","Like try!(), but wrapping the error value in `IronError`. To be used in request handlers."]],"mod":[["error","Iron's error type and associated utilities."],["headers","Headers container, and common header fields.hyper has the opinion that Headers should be strongly-typed, because that's why we're using Rust in the first place. To set or get any header, an object must implement the `Header` trait from this module. Several common headers are already provided, such as `Host`, `ContentType`, `UserAgent`, and others.Why Typed?Or, why not stringly-typed? Types give the following advantages:More difficult to typo, since typos in types should be caught by the compiler Parsing to a proper type by default Defining Custom HeadersHyper provides many of the most commonly used headers in HTTP. If you need to define a custom header, it's easy to do while still taking advantage of the type system. Hyper includes a `header!` macro for defining many wrapper-style headers.This works well for simple \"string\" headers. But the header system actually involves 2 parts: parsing, and formatting. If you need to customize either part, you can do so.`Header` and `HeaderFormat`Consider a Do Not Track header. It can be true or false, but it represents that via the numerals `1` and `0`."],["method","HTTP Methods"],["middleware","Iron's Middleware and Handler SystemIron's Middleware system is best modeled with a diagram.With no errors, the flow looks like:A request first travels through all BeforeMiddleware, then a Response is generated by the Handler, which can be an arbitrary nesting of AroundMiddleware, then all AfterMiddleware are called with both the Request and Response. After all AfterMiddleware have been fired, the response is written back to the client.Iron's error handling system is pragmatic and focuses on tracking two pieces of information for error receivers (other middleware):The cause of the error The result (what to do about) the error. The cause of the error is represented simply by the error itself, and the result of the error, representing the action to take in response to the error, is a complete Response, which will be sent at the end of the error flow.When an error is thrown in Iron by any middleware or handler returning an `Err` variant with an `IronError`, the flow of the Request switches to the error flow, which proceeds to just call the `catch` method of middleware and sidesteps the `Handler` entirely, since there is already a Response in the error.A Request can exit the error flow by returning an Ok from any of the catch methods. This resumes the flow at the middleware immediately following the middleware which handled the error. It is impossible to \"go back\" to an earlier middleware that was skipped.Generally speaking, returning a 5XX error code means that the error flow should be entered by raising an explicit error. Dealing with 4XX errors is trickier, since the server may not want to recognize an error that is entirely the clients fault; handling of 4XX error codes is up to to each application and middleware author.Middleware authors should be cognizant that their middleware may be skipped during the error flow. Anything that *must* be done to each Request or Response should be run during both the normal and error flow by implementing the `catch` method to also do the necessary action."],["mime","Re-exporting the mime crate, for convenience."],["modifier","Re-exports from the Modifier crate."],["modifiers","Defines a series of convenience modifiers for editing ResponsesModifiers can be used to edit Responses through the owning method `set` or the mutating `set_mut`, both of which are defined in the `Set` trait.Instead of having a combinatorial explosion of Response methods and constructors, this provides a series of modifiers that can be used through the `Set` trait.For instance, instead of `Response::redirect` constructing a redirect response, we provide a `Redirect` modifier, so you can just do:This is more extensible as it allows you to combine arbitrary modifiers without having a massive number of Response constructors.For more information about the modifier system, see rust-modifier."],["prelude","A module meant to be glob imported when using Iron.For instance:This module contains several important traits that provide many of the convenience methods in Iron, as well as `Request`, `Response` `IronResult`, `IronError` and `Iron`."],["request","Iron's HTTP Request representation and associated methods."],["response","Iron's HTTP Response representation and associated methods."],["status","Status Codes"],["typemap","Re-exports from the TypeMap crate."]],"struct":[["Headers","A map of header fields on requests and responses."],["Iron","The primary entrance point to `Iron`, a `struct` to instantiate a new server.`Iron` contains the `Handler` which takes a `Request` and produces a `Response`."],["Timeouts","A settings struct containing a set of timeouts which can be applied to a server."],["TypeMap","A map keyed by types.Can contain one value of any type for each key type, as defined by the Assoc trait.You usually do not need to worry about the A type parameter, but it can be used to add bounds to the possible value types that can be stored in this map. Usually, you are looking for `ShareMap`, which is `Send + Sync`."],["Url","HTTP/HTTPS URL type for Iron."]],"trait":[["Error","An extension to std::error::Error which provides dynamic downcasting of errors for use in highly generic contexts.When to use this traitIn the vast majority of cases, a library-specific `enum` should be used for cases where there can be many different types of errors. This has the benefit of being very performant and benefiting from all sorts of static checking at both the instantiation site and the handling site of the error.In other cases, being generic over `std::error::Error` may be correct - usually for logging errors or in other places where an error is used as *input*.Now, a motivating example for this trait, which doesn't fall under either of these cases:Imagine we are creating a simple web middleware for verifying incoming HTTP requests. It will take in many different user-defined `Verifier`s and will call them one after the other, rejecting the request on any error.The first step would be to write a `Verifier` trait:A problem quickly arises - what type do we use for the `Err` case? We cannot use a concrete type since each `Verifier` may wish to throw any number of different errors, and we cannot use a generic since the type is chosen by the implementor, not the caller, and it cannot be a generic on the trait since we will want to store many `Verifier`s together.Enter: `Box<error::Error>`, a type which can be used to represent any `std::error::Error` with the sufficient bounds, and can *also* be handled later by downcasting it to the right error using either `.downcast` or the `match_error!` macro. This type can be used to meet the needs of consumers like `Verifier`, but should not be used in cases where enums or generics are better suited."],["Plugin","An interface for plugins that cache values between calls.`R` is the type of the plugin's return value, which must be cloneable."],["Set","A trait providing the set and set_mut methods for all types.Simply implement this for your types and they can be used with modifiers."]],"type":[["IronResult","The Result alias used throughout Iron and in clients of Iron."]]});